package com.puc.projectgrafo

import android.os.Bundle
import android.widget.EditText
import android.widget.TextView
import androidx.appcompat.app.AppCompatActivity
import com.google.firebase.firestore.FirebaseFirestore
import com.puc.projectgrafo.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var resultTextView: TextView
    private lateinit var binding: ActivityMainBinding

    private lateinit var editText: EditText
    private lateinit var editText2: EditText

    private var origem: Int = 0
    private var destino: Int = 0

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        resultTextView = binding.resultTextView
        editText = binding.impOrigem
        editText2 = binding.impDestino

        binding.calculateButton.setOnClickListener {
            calculateShortestPaths()
        }
    }

    private fun calculateShortestPaths() {
        val origemText = editText.text.toString()
        val destinoText = editText2.text.toString()

        if (origemText.isNotEmpty() && destinoText.isNotEmpty()) {
            origem = origemText.toInt()
            destino = destinoText.toInt()

            val graph = Graph(2)

            val db = FirebaseFirestore.getInstance()
            val graphCollectionRef = db.collection("graphs")

            // Query the collection and retrieve the documents
            graphCollectionRef.get()
                .addOnSuccessListener { querySnapshot ->
                    for (documentSnapshot in querySnapshot) {
                        val source = documentSnapshot.getLong("source")?.toInt() ?: 0
                        val destination = documentSnapshot.getLong("destination")?.toInt() ?: 0
                        val weight = documentSnapshot.getLong("weight")?.toInt() ?: 0

                        // Add the edge to the graph
                        graph.addEdge(source, destination, weight)
                    }
                }
                .addOnFailureListener { exception ->
                    // Handle any errors that occur during the retrieval process
                }

            val distances = graph.dijkstra(origem)

            resultTextView.text = ""
            val i = destino
            if (i != origem) {
                val result =
                    "Tempo mínimo entre o prédio $origem e o prédio $i: ${distances[i]} minutos"
                resultTextView.append("$result\n")
            }
        }
    }

    class Graph(private val numVertices: Int) {
        private val adjacencyMatrix: Array<IntArray> = Array(numVertices) { IntArray(numVertices) }

        fun addEdge(source: Int, destination: Int, weight: Int) {
            adjacencyMatrix[source][destination] = weight
            adjacencyMatrix[destination][source] = weight
        }

        fun dijkstra(source: Int): IntArray {
            val distance = IntArray(numVertices) { Int.MAX_VALUE }
            val visited = BooleanArray(numVertices)
            distance[source] = 0

            for (count in 0 until numVertices - 1) {
                val u = getMinimumDistanceVertex(distance, visited)
                visited[u] = true

                for (v in 0 until numVertices) {
                    if (!visited[v] && adjacencyMatrix[u][v] != 0 && distance[u] != Int.MAX_VALUE) {
                        val newDistance = distance[u] + adjacencyMatrix[u][v]
                        if (newDistance < distance[v]) {
                            distance[v] = newDistance
                        }
                    }
                }
            }
            return distance
        }

        private fun getMinimumDistanceVertex(distance: IntArray, visited: BooleanArray): Int {
            var minDistance = Int.MAX_VALUE
            var minVertex = -1

            for (v in 0 until numVertices) {
                if (!visited[v] && distance[v] <= minDistance) {
                    minDistance = distance[v]
                    minVertex = v
                }
            }
            return minVertex
        }
    }
}
